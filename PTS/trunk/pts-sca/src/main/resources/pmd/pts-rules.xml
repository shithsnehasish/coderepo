<?xml version="1.0"?>

<!-- Basic -->
<ruleset name="Basic" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
	<description>
The Basic ruleset contains a collection of good practices which should be followed.
  </description>

	<rule name="JumbledIncrementer" language="java" since="1.0"
		message="Avoid modifying an outer loop incrementer in an inner loop for update expression"
		class="net.sourceforge.pmd.lang.rule.XPathRule" 
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#JumbledIncrementer">
		<description>
Avoid jumbled loop incrementers - its usually a mistake, and is confusing even if intentional.
     </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
 <![CDATA[
//ForStatement
 [
  ForUpdate/StatementExpressionList/StatementExpression/PostfixExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
  =
  ancestor::ForStatement/ForInit//VariableDeclaratorId/@Image
 ]
 ]]>
             </value>
			</property>
		</properties>
		<example>
 <![CDATA[
public class JumbledIncrementerRule1 {
	public void foo() {
		for (int i = 0; i < 10; i++) {			// only references 'i'
			for (int k = 0; k < 20; i++) {		// references both 'i' and 'k'
				System.out.println("Hello");
			}
		}
	}
}
 ]]>
     </example>
	</rule>

	<rule name="ForLoopShouldBeWhileLoop" language="java" since="1.02"
		message="This for loop could be simplified to a while loop" class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#ForLoopShouldBeWhileLoop">
		<description>
Some for loops can be simplified to while loops, this makes them more concise.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                <![CDATA[
//ForStatement
 [count(*) > 1]
 [not(LocalVariableDeclaration)]
 [not(ForInit)]
 [not(ForUpdate)]
 [not(Type and Expression and Statement)]
 ]]>
            </value>
			</property>
		</properties>
		<example>
  <![CDATA[
public class Foo {
	void bar() {
		for (;true;) true; // No Init or Update part, may as well be: while (true)
	}
}
 ]]>
      </example>
	</rule>

	<rule name="OverrideBothEqualsAndHashcode" language="java" since="0.4"
		message="Ensure you override both equals() and hashCode()"
		class="net.sourceforge.pmd.lang.java.rule.basic.OverrideBothEqualsAndHashcodeRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#OverrideBothEqualsAndHashcode">
		<description>
Override both public boolean Object.equals(Object other), and public int Object.hashCode(), or override neither.  Even if you are inheriting a hashCode() from a parent class, consider implementing hashCode and explicitly delegating to your superclass.
      </description>
		<priority>3</priority>
		<example>
  <![CDATA[
public class Bar {		// poor, missing a hashcode() method
	public boolean equals(Object o) {
      // do some comparison
	}
}

public class Baz {		// poor, missing an equals() method
	public int hashCode() {
      // return some hash value
	}
}

public class Foo {		// perfect, both methods provided
	public boolean equals(Object other) {
      // do some comparison
	}
	public int hashCode() {
      // return some hash value
	}
}
 ]]>
      </example>
	</rule>

	<rule name="DoubleCheckedLocking" language="java" since="1.04"
		message="Double checked locking is not thread safe in Java."
		class="net.sourceforge.pmd.lang.java.rule.basic.DoubleCheckedLockingRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#DoubleCheckedLocking">
		<description>
Partially created objects can be returned by the Double Checked Locking pattern when used in Java.
An optimizing JRE may assign a reference to the baz variable before it creates the object the
reference is intended to point to.

For more details refer to: http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html
      </description>
		<priority>1</priority>
		<example>
  <![CDATA[
public class Foo {
	Object baz;
	Object bar() {
		if (baz == null) { // baz may be non-null yet not fully created
			synchronized(this) {
				if (baz == null) {
					baz = new Object();
        		}
      		}
    	}
		return baz;
	}
}
 ]]>
      </example>
	</rule>

	<rule name="ReturnFromFinallyBlock" language="java" since="1.05"
		message="Avoid returning from a finally block" class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#ReturnFromFinallyBlock">
		<description>
Avoid returning from a finally block, this can discard exceptions.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//FinallyStatement//ReturnStatement
]]>
              </value>
			</property>
		</properties>
		<example>
  <![CDATA[
public class Bar {
	public String foo() {
		try {
			throw new Exception( "My Exception" );
		} catch (Exception e) {
			throw e;
		} finally {
			return "A. O. K."; // return not recommended here
		}
	}
}
]]>
      </example>
	</rule>

	<rule name="UnconditionalIfStatement" language="java" since="1.5"
		message="Do not use 'if' statements that are always true or always false"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#UnconditionalIfStatement">
		<description>
Do not use "if" statements whose conditionals are always true or always false.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
 <![CDATA[
//IfStatement/Expression
 [count(PrimaryExpression)=1]
 /PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral
]]>
                </value>
			</property>
		</properties>
		<example>
  <![CDATA[
public class Foo {
	public void close() {
		if (true) {		// fixed conditional, not recommended
			// ...
		}
	}
}
]]>
      </example>
	</rule>

	<rule name="BooleanInstantiation" since="1.2"
		message="Avoid instantiating Boolean objects; reference Boolean.TRUE or Boolean.FALSE or call Boolean.valueOf() instead."
		class="net.sourceforge.pmd.lang.java.rule.basic.BooleanInstantiationRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#BooleanInstantiation">
		<description>
Avoid instantiating Boolean objects; you can reference Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf() instead.
   </description>
		<priority>2</priority>
		<example>
   <![CDATA[
Boolean bar = new Boolean("true");		// unnecessary creation, just reference Boolean.TRUE;
Boolean buz = Boolean.valueOf(false);	// ...., just reference Boolean.FALSE;
   ]]>
   </example>
	</rule>

	<rule name="CollapsibleIfStatements" language="java" since="3.1"
		message="These nested if statements could be combined" class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#CollapsibleIfStatements">
		<description>
Sometimes two consecutive 'if' statements can be consolidated by separating their conditions with a boolean short-circuit operator.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                <![CDATA[
//IfStatement[@Else='false']/Statement
 /IfStatement[@Else='false']
 |
//IfStatement[@Else='false']/Statement
 /Block[count(BlockStatement)=1]/BlockStatement
  /Statement/IfStatement[@Else='false']]]>
            </value>
			</property>
		</properties>
		<example>
  <![CDATA[
void bar() {
	if (x) {			// original implementation
		if (y) {
			// do stuff
		}
	}
}

void bar() {
	if (x && y) {		// optimized implementation
		// do stuff
	}
}
 ]]>
      </example>
	</rule>

	<rule name="ClassCastExceptionWithToArray" language="java" since="3.4"
		message="This usage of the Collection.toArray() method will throw a ClassCastException."
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#ClassCastExceptionWithToArray">
		<description>
When deriving an array of a specific class from your Collection, one should provide an array of
the same class as the parameter of the toArray() method. Doing otherwise you will will result
in a ClassCastException.
  </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//CastExpression[Type/ReferenceType/ClassOrInterfaceType[@Image !=
"Object"]]/PrimaryExpression
[
 PrimaryPrefix/Name[ends-with(@Image, '.toArray')]
 and
 PrimarySuffix/Arguments[count(*) = 0]
and
count(PrimarySuffix) = 1
]
]]>
    </value>
			</property>
		</properties>
		<example>
<![CDATA[
Collection c = new ArrayList();
Integer obj = new Integer(1);
c.add(obj);

    // this would trigger the rule (and throw a ClassCastException if executed)
Integer[] a = (Integer [])c.toArray();

   // this is fine and will not trigger the rule
Integer[] b = (Integer [])c.toArray(new Integer[c.size()]);
]]>
  </example>
	</rule>


	<rule name="AvoidDecimalLiteralsInBigDecimalConstructor" language="java"
		since="3.4"
		message="Avoid creating BigDecimal with a decimal (float/double) literal. Use a String literal"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#AvoidDecimalLiteralsInBigDecimalConstructor">
		<description>
One might assume that the result of "new BigDecimal(0.1)" is exactly equal to 0.1, but it is actually
equal to .1000000000000000055511151231257827021181583404541015625.
This is because 0.1 cannot be represented exactly as a double (or as a binary fraction of any finite
length). Thus, the long value that is being passed in to the constructor is not exactly equal to 0.1,
appearances notwithstanding.

The (String) constructor, on the other hand, is perfectly predictable: 'new BigDecimal("0.1")' is
exactly equal to 0.1, as one would expect.  Therefore, it is generally recommended that the
(String) constructor be used in preference to this one.
  </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//AllocationExpression[ClassOrInterfaceType[@Image="BigDecimal"]
and
./Arguments/ArgumentList
/Expression/PrimaryExpression/PrimaryPrefix/Literal[(not
(ends-with
(@Image,'"'))) and contains(@Image,".")]]
 ]]>
    </value>
			</property>
		</properties>
		<example>
<![CDATA[
BigDecimal bd = new BigDecimal(1.123);		// loss of precision, this would trigger the rule

BigDecimal bd = new BigDecimal("1.123");   	// preferred approach

BigDecimal bd = new BigDecimal(12);     	// preferred approach, ok for integer values
]]>
  </example>
	</rule>


	<rule name="MisplacedNullCheck" language="java" since="3.5"
		message="The null check here is misplaced; if the variable is null there'll be a NullPointerException"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#MisplacedNullCheck">
		<description>
The null check here is misplaced. If the variable is null a NullPointerException will be thrown.
Either the check is useless (the variable will never be "null") or it is incorrect.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
    <![CDATA[
//Expression
    /*[self::ConditionalOrExpression or self::ConditionalAndExpression]
    /descendant::PrimaryExpression/PrimaryPrefix
    /Name[starts-with(@Image,
        concat(ancestor::PrimaryExpression/following-sibling::EqualityExpression
            [./PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]
            /PrimaryExpression/PrimaryPrefix
            /Name[count(../../PrimarySuffix)=0]/@Image,".")
        )
     ]
     [count(ancestor::ConditionalAndExpression/EqualityExpression
            [@Image='!=']
            [./PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]
            [starts-with(following-sibling::*/PrimaryExpression/PrimaryPrefix/Name/@Image,
                concat(./PrimaryExpression/PrimaryPrefix/Name/@Image, '.'))]
      ) = 0
     ]
    ]]>
        </value>
			</property>
		</properties>
		<example>
    <![CDATA[
public class Foo {
	void bar() {
		if (a.equals(baz) && a != null) {}
		}
}
    ]]>
      </example>
		<example><![CDATA[
public class Foo {
	void bar() {
		if (a.equals(baz) || a == null) {}
	}
}
   ]]></example>
	</rule>


	<rule name="AvoidThreadGroup" language="java" since="3.6"
		message="Avoid using java.lang.ThreadGroup; it is not thread safe"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#AvoidThreadGroup"
		typeResolution="true">
		<description>
Avoid using java.lang.ThreadGroup; although it is intended to be used in a threaded environment
it contains methods that are not thread-safe.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//AllocationExpression/ClassOrInterfaceType[pmd-java:typeof(@Image, 'java.lang.ThreadGroup')]|
//PrimarySuffix[contains(@Image, 'getThreadGroup')]
]]>
        </value>
			</property>
		</properties>
		<example>
    <![CDATA[
public class Bar {
	void buz() {
		ThreadGroup tg = new ThreadGroup("My threadgroup") ;
		tg = new ThreadGroup(tg, "my thread group");
		tg = Thread.currentThread().getThreadGroup();
		tg = System.getSecurityManager().getThreadGroup();
	}
}
    ]]>
      </example>
	</rule>

	<rule name="BrokenNullCheck" since="3.8"
		message="Method call on object which may be null" class="net.sourceforge.pmd.lang.java.rule.basic.BrokenNullCheckRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#BrokenNullCheck">
		<description>
The null check is broken since it will throw a NullPointerException itself.
It is likely that you used || instead of &amp;&amp; or vice versa.
     </description>
		<priority>2</priority>
		<example>
<![CDATA[
public String bar(String string) {
  // should be &&
	if (string!=null || !string.equals(""))
		return string;
  // should be ||
	if (string==null && string.equals(""))
		return string;
}
        ]]>
        </example>
	</rule>

	<rule name="BigIntegerInstantiation" since="3.9"
		message="Don't create instances of already existing BigInteger and BigDecimal (ZERO, ONE, TEN)"
		class="net.sourceforge.pmd.lang.java.rule.basic.BigIntegerInstantiationRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#BigIntegerInstantiation">
		<description>
Don't create instances of already existing BigInteger (BigInteger.ZERO, BigInteger.ONE) and
for Java 1.5 onwards, BigInteger.TEN and BigDecimal (BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN)
  </description>
		<priority>3</priority>
		<example>
<![CDATA[
BigInteger bi = new BigInteger(1);		// reference BigInteger.ONE instead
BigInteger bi2 = new BigInteger("0");	// reference BigInteger.ZERO instead
BigInteger bi3 = new BigInteger(0.0);	// reference BigInteger.ZERO instead
BigInteger bi4;
bi4 = new BigInteger(0);				// reference BigInteger.ZERO instead
]]>
  </example>
	</rule>

	<rule name="AvoidUsingOctalValues" since="3.9"
		message="Do not start a literal by 0 unless it's an octal value"
		class="net.sourceforge.pmd.lang.java.rule.basic.AvoidUsingOctalValuesRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#AvoidUsingOctalValues">
		<description>
    	<![CDATA[
Integer literals should not start with zero since this denotes that the rest of literal will be
interpreted as an octal value.
    	]]>
    </description>
		<priority>3</priority>
		<example>
		    <![CDATA[
int i = 012;	// set i with 10 not 12
int j = 010;	// set j with 8 not 10
k = i * j;		// set k with 80 not 120
		    ]]>
    </example>
	</rule>

	<rule name="AvoidUsingHardCodedIP" since="4.1"
		message="Do not hard code the IP address ${variableName}"
		class="net.sourceforge.pmd.lang.java.rule.basic.AvoidUsingHardCodedIPRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#AvoidUsingHardCodedIP">
		<description>
	    	<![CDATA[
Application with hard-coded IP addresses can become impossible to deploy in some cases.
Externalizing IP adresses is preferable.
	    	]]>
	    </description>
		<priority>3</priority>
		<properties>
			<property name="pattern" type="String" description="Regular Expression"
				value='^"[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"$' />
		</properties>
		<example>
	    <![CDATA[
public class Foo {
	private String ip = "127.0.0.1"; 	// not recommended
}
	    ]]>
	    </example>
	</rule>

	<rule name="CheckResultSet" language="java" since="4.1"
		class="net.sourceforge.pmd.lang.java.rule.basic.CheckResultSetRule"
		message="Always check the return of one of the navigation method (next,previous,first,last) of a ResultSet."
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#CheckResultSet">
		<description>
            <![CDATA[
Always check the return values of navigation methods (next, previous, first, last) of a ResultSet.
If the value return is 'false', it should be handled properly.
            ]]>
        </description>
		<priority>3</priority>
		<example>
            <![CDATA[
Statement stat = conn.createStatement();
ResultSet rst = stat.executeQuery("SELECT name FROM person");
rst.next(); 	// what if it returns false? bad form
String firstName = rst.getString(1);

Statement stat = conn.createStatement();
ResultSet rst = stat.executeQuery("SELECT name FROM person");
if (rst.next()) {	// result is properly examined and used
    String firstName = rst.getString(1);
	} else  {
		// handle missing data
}
            ]]>
        </example>
	</rule>

	<rule name="AvoidMultipleUnaryOperators" since="4.2"
		class="net.sourceforge.pmd.lang.java.rule.basic.AvoidMultipleUnaryOperatorsRule"
		message="Using multiple unary operators may be a bug, and/or is confusing."
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#AvoidMultipleUnaryOperators">
		<description>
            <![CDATA[
The use of multiple unary operators may be problematic, and/or confusing.
Ensure that the intended usage is not a bug, or consider simplifying the expression.
            ]]>
        </description>
		<priority>2</priority>
		<example>
            <![CDATA[
// These are typo bugs, or at best needlessly complex and confusing:
int i = - -1;
int j = + - +1;
int z = ~~2;
boolean b = !!true;
boolean c = !!!true;

// These are better:
int i = 1;
int j = -1;
int z = 2;
boolean b = true;
boolean c = false;

// And these just make your brain hurt:
int i = ~-2;
int j = -~7;
            ]]>
        </example>
	</rule>

	<rule name="ExtendsObject" language="java" since="5.0"
		message="No need to explicitly extend Object." class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#ExtendsObject">
		<description>No need to explicitly extend Object.</description>
		<priority>4</priority>
		<properties>
			<property name="xpath">
				<value>
          <![CDATA[
//ExtendsList/ClassOrInterfaceType[@Image='Object' or @Image='java.lang.Object']
          ]]>
          </value>
			</property>
		</properties>
		<example>
    <![CDATA[
public class Foo extends Object { 	// not required
}
    ]]>
    </example>
	</rule>

	<rule name="CheckSkipResult" language="java" since="5.0"
		message="Check the value returned by the skip() method of an InputStream to see if the requested number of bytes has been skipped."
		class="net.sourceforge.pmd.lang.java.rule.basic.CheckSkipResultRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#CheckSkipResult">
		<description>The skip() method may skip a smaller number of bytes than requested. Check the returned value to find out if it was the case or not.</description>
		<priority>3</priority>
		<example>
        <![CDATA[
public class Foo {

   private FileInputStream _s = new FileInputStream("file");

   public void skip(int n) throws IOException {
      _s.skip(n); // You are not sure that exactly n bytes are skipped
   }

   public void skipExactly(int n) throws IOException {
      while (n != 0) {
         long skipped = _s.skip(n);
         if (skipped == 0)
            throw new EOFException();
         n -= skipped;
      }
   }
        ]]>
        </example>
	</rule>

	<rule name="AvoidBranchingStatementAsLastInLoop" since="5.0"
		class="net.sourceforge.pmd.lang.java.rule.basic.AvoidBranchingStatementAsLastInLoopRule"
		message="Avoid using a branching statement as the last in a loop."
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#AvoidBranchingStatementAsLastInLoop">
		<description>
            <![CDATA[
Using a branching statement as the last part of a loop may be a bug, and/or is confusing.
Ensure that the usage is not a bug, or consider using another approach.
            ]]>
        </description>
		<priority>2</priority>
		<example>
            <![CDATA[
  // unusual use of branching statement in a loop
for (int i = 0; i < 10; i++) {
	if (i*i <= 25) {
		continue;
	}
	break;
}

  // this makes more sense...
for (int i = 0; i < 10; i++) {
	if (i*i > 25) {
		break;
	}
}
            ]]>
        </example>
	</rule>

	<rule name="DontCallThreadRun" language="java" since="4.3"
		message="Don't call Thread.run() explicitly, use Thread.start()"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#DontCallThreadRun">
		<description>
Explicitly calling Thread.run() method will execute in the caller's thread of control.  Instead, call Thread.start() for the intended behavior.
      </description>
		<priority>4</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//StatementExpression/PrimaryExpression
[
    PrimaryPrefix
    [
        ./Name[ends-with(@Image, '.run') or @Image = 'run']
        and substring-before(Name/@Image, '.') =//VariableDeclarator/VariableDeclaratorId/@Image
        [../../../Type/ReferenceType[ClassOrInterfaceType/@Image = 'Thread']]
        or (
        ./AllocationExpression/ClassOrInterfaceType[@Image = 'Thread']
        and ../PrimarySuffix[@Image = 'run'])
    ]
]
]]>
         </value>
			</property>
		</properties>
		<example>
<![CDATA[
Thread t = new Thread();
t.run();            // use t.start() instead
new Thread().run(); // same violation
]]>
      </example>
	</rule>

	<rule name="DontUseFloatTypeForLoopIndices" language="java" since="4.3"
		message="Don't use floating point for loop indices. If you must use floating point, use double."
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/basic.html#DontUseFloatTypeForLoopIndices">
		<description>
Don't use floating point for loop indices. If you must use floating point, use double
unless you're certain that float provides enough precision and you have a compelling
performance need (space or time).
    </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//ForStatement/ForInit/LocalVariableDeclaration
/Type/PrimitiveType[@Image="float"]
]]>
       </value>
			</property>
		</properties>
		<example>
<![CDATA[
public class Count {
  public static void main(String[] args) {
    final int START = 2000000000;
    int count = 0;
    for (float f = START; f < START + 50; f++)
      count++;
      //Prints 0 because (float) START == (float) (START + 50).
      System.out.println(count);
      //The termination test misbehaves due to floating point granularity.
    }
}
]]>
    </example>
	</rule>

	<!-- String -->
	

	<rule name="StringInstantiation" since="1.0"
		message="Avoid instantiating String objects; this is usually unnecessary."
		class="net.sourceforge.pmd.lang.java.rule.strings.StringInstantiationRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#StringInstantiation">
		<description>
Avoid instantiating String objects; this is usually unnecessary since they are immutable and can be safely shared.
    </description>
		<priority>2</priority>
		<example>
<![CDATA[
private String bar = new String("bar"); // just do a String bar = "bar";
]]>
    </example>
	</rule>

	<rule name="StringToString" since="1.0"
		message="Avoid calling toString() on String objects; this is unnecessary."
		class="net.sourceforge.pmd.lang.java.rule.strings.StringToStringRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#StringToString">
		<description>
Avoid calling toString() on objects already known to be string instances; this is unnecessary.
    </description>
		<priority>3</priority>
		<example>
<![CDATA[
private String baz() {
    String bar = "howdy";
    return bar.toString();
}
]]>
    </example>
	</rule>

	<rule name="InefficientStringBuffering" since="3.4"
		message="Avoid concatenating nonliterals in a StringBuffer/StringBuilder constructor or append()."
		class="net.sourceforge.pmd.lang.java.rule.strings.InefficientStringBufferingRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#InefficientStringBuffering">
		<description>
Avoid concatenating non-literals in a StringBuffer constructor or append() since intermediate buffers will
need to be be created and destroyed by the JVM.
    </description>
		<priority>3</priority>
		<example>
<![CDATA[
    // Avoid this, two buffers are actually being created here
StringBuffer sb = new StringBuffer("tmp = "+System.getProperty("java.io.tmpdir"));
    
    // do this instead
StringBuffer sb = new StringBuffer("tmp = ");
sb.append(System.getProperty("java.io.tmpdir"));
]]>
    </example>
	</rule>

	<rule name="UnnecessaryCaseChange" since="3.3"
		message="Using equalsIgnoreCase() is cleaner than using toUpperCase/toLowerCase().equals()."
		class="net.sourceforge.pmd.lang.java.rule.strings.UnnecessaryCaseChangeRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#UnnecessaryCaseChange">
		<description>
Using equalsIgnoreCase() is faster than using toUpperCase/toLowerCase().equals()
       </description>
		<priority>3</priority>
		<example>
       <![CDATA[
boolean answer1 = buz.toUpperCase().equals("baz");	 		// should be buz.equalsIgnoreCase("baz")
    
boolean answer2 = buz.toUpperCase().equalsIgnoreCase("baz");	 // another unnecessary toUpperCase()
 ]]>
       </example>
	</rule>

	<rule name="UseStringBufferLength" since="3.4"
		message="This is an inefficient use of StringBuffer.toString; call StringBuffer.length instead."
		class="net.sourceforge.pmd.lang.java.rule.strings.UseStringBufferLengthRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#UseStringBufferLength">
		<description>
Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("")
or StringBuffer.toString().length() == ...
      </description>
		<priority>3</priority>
		<example>
  <![CDATA[
StringBuffer sb = new StringBuffer();
    
if (sb.toString().equals("")) {}	    // inefficient 
    
if (sb.length() == 0) {}	    		// preferred
  ]]>
      </example>
	</rule>


	<rule name="AppendCharacterWithChar" since="3.5"
		message="Avoid appending characters as strings in StringBuffer.append."
		class="net.sourceforge.pmd.lang.java.rule.strings.AppendCharacterWithCharRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#AppendCharacterWithChar">
		<description>
Avoid concatenating characters as strings in StringBuffer/StringBuilder.append methods.
    </description>
		<priority>3</priority>
		<example>
<![CDATA[
StringBuffer sb = new StringBuffer();
sb.append("a");		 // avoid this

StringBuffer sb = new StringBuffer();
sb.append('a');		// use this instead
]]>
    </example>
	</rule>

	<rule name="ConsecutiveLiteralAppends" since="3.5"
		message="StringBuffer (or StringBuilder).append is called {0} consecutive times with literal Strings. Use a single append with a single combined String."
		class="net.sourceforge.pmd.lang.java.rule.strings.ConsecutiveLiteralAppendsRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#ConsecutiveLiteralAppends">
		<description>
Consecutively calling StringBuffer/StringBuilder.append with String literals
    </description>
		<priority>3</priority>
		<example>
<![CDATA[
StringBuffer buf = new StringBuffer();
buf.append("Hello").append(" ").append("World"); // poor
buf.append("Hello World");        				 // good
]]>
    </example>
	</rule>


	<rule name="UseIndexOfChar" since="3.5"
		message="String.indexOf(char) is faster than String.indexOf(String)."
		class="net.sourceforge.pmd.lang.java.rule.strings.UseIndexOfCharRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#UseIndexOfChar">
		<description>
Use String.indexOf(char) when checking for the index of a single character; it executes faster.
    </description>
		<priority>3</priority>
		<example>
<![CDATA[
String s = "hello world";
  // avoid this
if (s.indexOf("d") {}
  // instead do this
if (s.indexOf('d') {}
]]>
    </example>
	</rule>

	<rule name="InefficientEmptyStringCheck" since="3.6"
		message="String.trim().length()==0 is an inefficient way to validate an empty String."
		class="net.sourceforge.pmd.lang.java.rule.strings.InefficientEmptyStringCheckRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#InefficientEmptyStringCheck">
		<description>
String.trim().length() is an inefficient way to check if a String is really empty, as it
creates a new String object just to check its size. Consider creating a static function that
loops through a string, checking Character.isWhitespace() on each character and returning
false if a non-whitespace character is found.
    </description>
		<priority>3</priority>
		<example>
<![CDATA[
public void bar(String string) {
	if (string != null && string.trim().size() > 0) {
		doSomething();
	}
}
]]>
    </example>
	</rule>

	<rule name="InsufficientStringBufferDeclaration" since="3.6"
		message="StringBuffer constructor is initialized with size {0}, but has at least {1} characters appended."
		class="net.sourceforge.pmd.lang.java.rule.strings.InsufficientStringBufferDeclarationRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#InsufficientStringBufferDeclaration">
		<description>
Failing to pre-size a StringBuffer or StringBuilder properly could cause it to re-size many times
during runtime. This rule attempts to determine the total number the characters that are actually 
passed into StringBuffer.append(), but represents a best guess "worst case" scenario. An empty
StringBuffer/StringBuilder constructor initializes the object to 16 characters. This default
is assumed if the length of the constructor can not be determined.
    </description>
		<priority>3</priority>
		<example>
<![CDATA[
StringBuffer bad = new StringBuffer();
bad.append("This is a long string that will exceed the default 16 characters");
        
StringBuffer good = new StringBuffer(41);
good.append("This is a long string, which is pre-sized");
]]>
    </example>
	</rule>

	<rule name="UselessStringValueOf" since="3.8"
		message="No need to call String.valueOf to append to a string."
		class="net.sourceforge.pmd.lang.java.rule.strings.UselessStringValueOfRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#UselessStringValueOf">
		<description>
No need to call String.valueOf to append to a string; just use the valueOf() argument directly.
      </description>
		<priority>3</priority>
		<example>
<![CDATA[
public String convert(int i) {
	String s;
	s = "a" + String.valueOf(i);	// not required
	s = "a" + i; 					// preferred approach
	return s;
}
]]>
          </example>
	</rule>


	<rule name="StringBufferInstantiationWithChar" language="java"
		since="3.9" message="Do not instantiate a StringBuffer or StringBuilder with a char"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#StringBufferInstantiationWithChar">
		<description>
Individual character values provided as initialization arguments will be converted into integers.
This can lead to internal buffer sizes that are larger than expected. Some examples:

new StringBuffer() 		//  16
new StringBuffer(6)		//  6
new StringBuffer("hello world")  // 11 + 16 = 27
new StringBuffer('A')	//  chr(A) = 65
new StringBuffer("A")   //  1 + 16 = 17 

new StringBuilder() 		//  16
new StringBuilder(6)		//  6
new StringBuilder("hello world")  // 11 + 16 = 27
new StringBuilder('C')	 //  chr(C) = 67
new StringBuilder("A")   //  1 + 16 = 17
    </description>
		<priority>4</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//AllocationExpression/ClassOrInterfaceType
[@Image='StringBuffer' or @Image='StringBuilder']
/../Arguments/ArgumentList/Expression/PrimaryExpression
/PrimaryPrefix/
Literal
  [starts-with(@Image, "'")]
  [ends-with(@Image, "'")]
]]>
            </value>
			</property>
		</properties>
		<example>
<![CDATA[
	// misleading instantiation, these buffers
	// are actually sized to 99 characters long
StringBuffer  sb1 = new StringBuffer('c');   
StringBuilder sb2 = new StringBuilder('c');
  
// in these forms, just single characters are allocated
StringBuffer  sb3 = new StringBuffer("c");
StringBuilder sb4 = new StringBuilder("c");
]]>
    </example>
	</rule>

	<rule name="UseEqualsToCompareStrings" language="java" since="4.1"
		message="Use equals() to compare strings instead of ''=='' or ''!=''"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#UseEqualsToCompareStrings">
		<description>
Using '==' or '!=' to compare strings only works if intern version is used on both sides.
Use the equals() method instead.
    </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//EqualityExpression/PrimaryExpression
[(PrimaryPrefix/Literal
   [starts-with(@Image, '"')]
   [ends-with(@Image, '"')]
and count(PrimarySuffix) = 0)]
]]>
            </value>
			</property>
		</properties>
		<example>
<![CDATA[
public boolean test(String s) {
    if (s == "one") return true; 		// unreliable
    if ("two".equals(s)) return true; 	// better
    return false;
}
]]>
    </example>
	</rule>

	<rule name="AvoidStringBufferField" language="java" since="4.2"
		message="StringBuffers can grow quite a lot, and so may become a source of memory leak (if the owning class has a long life time)."
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strings.html#AvoidStringBufferField">
		<description>
		<![CDATA[
StringBuffers/StringBuilders can grow considerably, and so may become a source of memory leaks
if held within objects with long lifetimes.
		]]>
    </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[@Image = 'StringBuffer' or @Image = 'StringBuilder']
]]>
			</value>
			</property>
		</properties>
		<example>
<![CDATA[
public class Foo {
	private StringBuffer buffer;	// potential memory leak as an instance variable;
}
]]>
		</example>
	</rule>

	<!-- Unnecessary -->
	<rule name="UnnecessaryConversionTemporary" since="0.1"
		message="Avoid unnecessary temporaries when converting primitives to Strings"
		class="net.sourceforge.pmd.lang.java.rule.unnecessary.UnnecessaryConversionTemporaryRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unnecessary.html#UnnecessaryConversionTemporary">
		<description>
Avoid the use temporary objects when converting primitives to Strings. Use the static conversion methods
on the wrapper classes instead.
      </description>
		<priority>3</priority>
		<example>
  <![CDATA[
public String convert(int x) {
	String foo = new Integer(x).toString();	// this wastes an object
	
	return Integer.toString(x);				// preferred approach
}
 ]]>
      </example>
	</rule>



	<rule name="UnnecessaryReturn" since="1.3"
		message="Avoid unnecessary return statements"
		class="net.sourceforge.pmd.lang.java.rule.unnecessary.UnnecessaryReturnRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unnecessary.html#UnnecessaryReturn">
		<description>
Avoid the use of unnecessary return statements.
      </description>
		<priority>3</priority>
		<example>
		<![CDATA[
public class Foo {
  public void bar() {
    int x = 42;
    return;
  }
}
		]]>
      </example>
	</rule>


	<rule name="UnnecessaryFinalModifier" language="java" since="3.0"
		message="Unnecessary final modifier in final class" class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unnecessary.html#UnnecessaryFinalModifier">
		<description>
When a class has the final modifier, all the methods are automatically final and do not need to be
tagged as such.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
    <![CDATA[
//ClassOrInterfaceDeclaration[@Final='true' and @Interface='false']
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration[@Final='true']
    ]]>
              </value>
			</property>
		</properties>
		<example>
<![CDATA[
public final class Foo {
    // This final modifier is not necessary, since the class is final
    // and thus, all methods are final
    private final void foo() {
    }
}

]]>
      </example>
	</rule>


	<rule name="UselessOverridingMethod" since="3.3"
		message="Overriding method merely calls super"
		class="net.sourceforge.pmd.lang.java.rule.unnecessary.UselessOverridingMethodRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unnecessary.html#UselessOverridingMethod">
		<description>
The overriding method merely calls the same method defined in a superclass.
        </description>
		<priority>3</priority>
		<example><![CDATA[
public void foo(String bar) {
  super.foo(bar);      // why bother overriding?
}

public String foo() {
	return super.foo();  // why bother overriding?
}

@Id
public Long getId() {
  return super.getId();  // OK if 'ignoreAnnotations' is false, which is the default behavior
}
        ]]></example>
	</rule>

	<rule name="UselessOperationOnImmutable" since="3.5"
		message="An operation on an Immutable object (String, BigDecimal or BigInteger) won't change the object itself"
		class="net.sourceforge.pmd.lang.java.rule.unnecessary.UselessOperationOnImmutableRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unnecessary.html#UselessOperationOnImmutable">
		<description>
An operation on an Immutable object (String, BigDecimal or BigInteger) won't change the object itself
since the result of the operation is a new object. Therefore, ignoring the operation result is an error.
      </description>
		<priority>3</priority>
		<example>
    <![CDATA[
import java.math.*;

class Test {
  void method1() {
    BigDecimal bd=new BigDecimal(10);
    bd.add(new BigDecimal(5)); 		// this will trigger the rule
  }
  void method2() {
    BigDecimal bd=new BigDecimal(10);
    bd = bd.add(new BigDecimal(5)); // this won't trigger the rule
  }
}
    ]]>
      </example>
	</rule>

	<rule name="UnusedNullCheckInEquals" language="java" since="3.5"
		message="Invoke equals() on the object you''ve already ensured is not null"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unnecessary.html#UnusedNullCheckInEquals">
		<description>
After checking an object reference for null, you should invoke equals() on that object rather than passing it to another object's equals() method.
    </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
        <![CDATA[
(//PrimaryPrefix[ends-with(Name/@Image, '.equals') and Name/@Image != 'Arrays.equals'] | //PrimarySuffix[@Image='equals' and not(../PrimaryPrefix/Literal)])
 /following-sibling::PrimarySuffix/Arguments/ArgumentList/Expression
 /PrimaryExpression[count(PrimarySuffix)=0]/PrimaryPrefix
 /Name[@Image = ./../../../../../../../../../../Expression/ConditionalAndExpression
 /EqualityExpression[@Image="!=" and count(./preceding-sibling::*)=0 and
 ./PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]
  /PrimaryExpression/PrimaryPrefix/Name/@Image]
        ]]>
        </value>
			</property>
		</properties>
		<example>
		<![CDATA[
public class Test {

  public String method1() { return "ok";}
  public String method2() { return null;}

  public void method(String a) {
    String b;
	// I don't know it method1() can be "null"
	// but I know "a" is not null..
	// I'd better write a.equals(method1())
	
	if (a!=null && method1().equals(a)) { // will trigger the rule
	//whatever
	}
	
	if (method1().equals(a) && a != null) { // won't trigger the rule
	//whatever
	}
	
	if (a!=null && method1().equals(b)) { // won't trigger the rule
	//whatever
	}
	
	if (a!=null && "LITERAL".equals(a)) { // won't trigger the rule
	//whatever
	}
	
	if (a!=null && !a.equals("go")) { // won't trigger the rule
	a=method2();
	if (method1().equals(a)) {
	//whatever
	}
  }
}
}
				]]>
			</example>
	</rule>

	
	<!-- Imports -->
	<rule name="DuplicateImports" since="0.5"
		message="Avoid duplicate imports such as ''{0}''"
		class="net.sourceforge.pmd.lang.java.rule.imports.DuplicateImportsRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/imports.html#DuplicateImports">
		<description>
Duplicate or overlapping import statements should be avoided.
    </description>
		<priority>4</priority>
		<example>
<![CDATA[
import java.lang.String;
import java.lang.*;
public class Foo {}
]]>
    </example>
	</rule>

	<rule name="DontImportJavaLang" since="0.5"
		message="Avoid importing anything from the package 'java.lang'"
		class="net.sourceforge.pmd.lang.java.rule.imports.DontImportJavaLangRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/imports.html#DontImportJavaLang">
		<description>
Avoid importing anything from the package 'java.lang'.  These classes are automatically imported (JLS 7.5.3).
    </description>
		<priority>4</priority>
		<example>
<![CDATA[
import java.lang.String;	// this is unnecessary

public class Foo {}

// --- in another source code file...

import java.lang.*;	// this is bad

public class Foo {}
]]>
    </example>
	</rule>

	<rule name="UnusedImports" since="1.0"
		message="Avoid unused imports such as ''{0}''" class="net.sourceforge.pmd.lang.java.rule.imports.UnusedImportsRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/imports.html#UnusedImports">
		<description>
Avoid the use of unused import statements to prevent unwanted dependencies.
    </description>
		<priority>4</priority>
		<example>
<![CDATA[
// this is bad
import java.io.File;
public class Foo {}
]]>
    </example>
	</rule>

	<rule name="ImportFromSamePackage" since="1.02"
		message="No need to import a type that lives in the same package"
		class="net.sourceforge.pmd.lang.java.rule.imports.ImportFromSamePackageRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/imports.html#ImportFromSamePackage">
		<description>
There is no need to import a type that lives in the same package.
     </description>
		<priority>3</priority>
		<example>
 <![CDATA[
 package foo;
 
 import foo.Buz; // no need for this
 import foo.*; // or this
 
 public class Bar{}
 ]]>
     </example>
	</rule>

	<rule name="TooManyStaticImports" language="java" since="4.1"
		class="net.sourceforge.pmd.lang.rule.XPathRule" message="Too many static imports may lead to messy code"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/imports.html#TooManyStaticImports">
		<description><![CDATA[
If you overuse the static import feature, it can make your program unreadable and 
unmaintainable, polluting its namespace with all the static members you import. 
Readers of your code (including you, a few months after you wrote it) will not know 
which class a static member comes from (Sun 1.5 Language Guide).
		 ]]></description>
		<priority>3</priority>
		<properties>
			<property name="maximumStaticImports" type="Integer"
				description="All static imports can be disallowed by setting this to 0"
				min="0" max="100" value="4" />
			<property name="xpath">
				<value><![CDATA[
.[count(ImportDeclaration[@Static = 'true']) > $maximumStaticImports]
	             ]]></value>
			</property>
		</properties>
		<example><![CDATA[
import static Lennon;
import static Ringo;
import static George;
import static Paul;
import static Yoko; // Too much !
		  ]]></example>
	</rule>

	<rule name="UnnecessaryFullyQualifiedName" language="java" since="5.0"
		class="net.sourceforge.pmd.lang.java.rule.imports.UnnecessaryFullyQualifiedNameRule"
		message="Unnecessary use of fully qualified name ''{0}'' due to existing import ''{1}''"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/imports.html#UnnecessaryFullyQualifiedName">
		<description><![CDATA[
Import statements allow the use of non-fully qualified names.  The use of a fully qualified name
which is covered by an import statement is redundant.  Consider using the non-fully qualified name.
		 ]]></description>
		<priority>4</priority>
		<example><![CDATA[
import java.util.List;

public class Foo {
   private java.util.List list1; // Unnecessary FQN
   private List list2; // More appropriate given import of 'java.util.List'
}
		  ]]></example>
	</rule>
	<!-- Unused Code -->
	<rule name="UnusedPrivateField" since="0.1" language="java"
		message="Avoid unused private fields such as ''{0}''."
		class="net.sourceforge.pmd.lang.java.rule.unusedcode.UnusedPrivateFieldRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unusedcode.html#UnusedPrivateField">
		<description>
Detects when a private field is declared and/or assigned a value, but not used.
    </description>
		<priority>3</priority>
		<example>
<![CDATA[
public class Something {
  private static int FOO = 2; // Unused
  private int i = 5; // Unused
  private int j = 6;
  public int addOne() {
    return j++;
  }
}
]]>
    </example>
	</rule>

	<rule name="UnusedLocalVariable" language="java" since="0.1"
		message="Avoid unused local variables such as ''{0}''."
		class="net.sourceforge.pmd.lang.java.rule.unusedcode.UnusedLocalVariableRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unusedcode.html#UnusedLocalVariable">
		<description>
Detects when a local variable is declared and/or assigned, but not used.
    </description>
		<priority>3</priority>

		<example>
<![CDATA[
public class Foo {
	public void doSomething() {
		int i = 5; // Unused
	}
}
]]>
    </example>
	</rule>

	<rule name="UnusedPrivateMethod" language="java" since="0.7"
		message="Avoid unused private methods such as ''{0}''."
		class="net.sourceforge.pmd.lang.java.rule.unusedcode.UnusedPrivateMethodRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unusedcode.html#UnusedPrivateMethod">
		<description>
Unused Private Method detects when a private method is declared but is unused.
    </description>
		<priority>3</priority>
		<example>
<![CDATA[
public class Something {
	private void foo() {} // unused
}
]]>
    </example>
	</rule>


	<rule name="UnusedFormalParameter" language="java" since="0.8"
		message="Avoid unused {0} parameters such as ''{1}''."
		class="net.sourceforge.pmd.lang.java.rule.unusedcode.UnusedFormalParameterRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unusedcode.html#UnusedFormalParameter">
		<description>
Avoid passing parameters to methods or constructors without actually referencing them in the method body.
    </description>
		<priority>3</priority>

		<example>
<![CDATA[
public class Foo {
	private void bar(String howdy) {
	// howdy is not used
	}
}
]]>
    </example>
	</rule>

	<rule name="UnusedModifier" language="java" since="1.02"
		message="Avoid modifiers which are implied by the context"
		class="net.sourceforge.pmd.lang.java.rule.unusedcode.UnusedModifierRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/unusedcode.html#UnusedModifier">
		<description>
Fields in interfaces are automatically public static final, and methods are public abstract.
Classes or interfaces nested in an interface are automatically public and static (all nested interfaces are automatically static).
For historical reasons, modifiers which are implied by the context are accepted by the compiler, but are superfluous.
     </description>
		<priority>3</priority>
		<example>
 <![CDATA[
public interface Foo {
  public abstract void bar(); 		// both abstract and public are ignored by the compiler
  public static final int X = 0; 	// public, static, and final all ignored
  public static class Bar {} 		// public, static ignored
  public static interface Baz {} 	// ditto
}
public class Bar {
  public static interface Baz {} // static ignored
}
 ]]>
     </example>
	</rule>
	<!-- Naming -->
	<rule name="ShortVariable" language="java" since="0.3"
		message="Avoid variables with short names like {0}" class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#ShortVariable">
		<description>
Fields, local variables, or parameter names that are very short are not helpful to the reader.
    </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                  <![CDATA[
//VariableDeclaratorId[string-length(@Image) < 3]
 [not(ancestor::ForInit)]
 [not((ancestor::FormalParameter) and (ancestor::TryStatement))]
                  ]]>
              </value>
			</property>
		</properties>
		<example>
<![CDATA[
public class Something {
	private int q = 15; 						// field - too short
	public static void main( String as[] ) {  	// formal arg - too short
		int r = 20 + q; 						// local var - too short
		for (int i = 0; i < 10; i++) { 			// not a violation (inside 'for' loop)
			r += q;
		}
	}
}
]]>
    </example>
	</rule>

	<rule name="ShortMethodName" language="java" since="0.3"
		message="Avoid using short method names" class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#ShortMethodName">
		<description>
Method names that are very short are not helpful to the reader.
     </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                  <![CDATA[
//MethodDeclarator[string-length(@Image) < 3]
                  ]]>
              </value>
			</property>
		</properties>
		<example>
<![CDATA[
public class ShortMethod {
	public void a( int i ) { // Violation
	}
}
]]>
     </example>
	</rule>


	<rule name="VariableNamingConventions" since="1.2"
		message="{0} variable {1} should begin with {2}"
		class="net.sourceforge.pmd.lang.java.rule.naming.VariableNamingConventionsRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#VariableNamingConventions">
		<description>
A variable naming conventions rule - customize this to your liking.  Currently, it
checks for final variables that should be fully capitalized and non-final variables
that should not include underscores.
        </description>
		<priority>1</priority>
		<example>
<![CDATA[
public class Foo {
   public static final int MY_NUM = 0;
   public String myTest = "";
   DataModule dmTest = new DataModule();
}
]]>
        </example>
	</rule>

	<rule name="MethodNamingConventions" since="1.2"
		message="Method name does not begin with a lower case character."
		class="net.sourceforge.pmd.lang.java.rule.naming.MethodNamingConventionsRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#MethodNamingConventions">
		<description>
Method names should always begin with a lower case character, and should not contain underscores.
          </description>
		<priority>1</priority>
		<example>
<![CDATA[
public class Foo {
	public void fooStuff() {
	}
}
]]>
          </example>
	</rule>

	<rule name="ClassNamingConventions" since="1.2"
		message="Class names should begin with an uppercase character"
		class="net.sourceforge.pmd.lang.java.rule.naming.ClassNamingConventionsRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#ClassNamingConventions">
		<description>
Class names should always begin with an upper case character.
      </description>
		<priority>1</priority>
		<example>
<![CDATA[
public class Foo {}
]]>
      </example>
	</rule>

	<rule name="AbstractNaming" language="java" since="1.4"
		message="Abstract classes should be named 'AbstractXXX'" class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#AbstractNaming">
		<description>
Abstract classes should be named 'AbstractXXX'.
       </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                    <![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true' and @Interface='false']
 [not (starts-with(@Image,'Abstract'))]
                    ]]>
                </value>
			</property>
		</properties>
		<example>
<![CDATA[
public abstract class Foo { // should be AbstractFoo
}
]]>
       </example>
	</rule>

	<rule name="AvoidDollarSigns" since="1.5"
		message="Avoid using dollar signs in variable/method/class/interface names"
		class="net.sourceforge.pmd.lang.java.rule.naming.AvoidDollarSignsRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#AvoidDollarSigns">
		<description>
Avoid using dollar signs in variable/method/class/interface names.
       </description>
		<priority>3</priority>
		<example>
   <![CDATA[
public class Fo$o {  // not a recommended name
}
   ]]>
       </example>
	</rule>

	<rule name="MethodWithSameNameAsEnclosingClass" since="1.5"
		message="Classes should not have non-constructor methods with the same name as the class"
		class="net.sourceforge.pmd.lang.java.rule.naming.MethodWithSameNameAsEnclosingClassRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#MethodWithSameNameAsEnclosingClass">
		<description>
Non-constructor methods should not have the same name as the enclosing class.
       </description>
		<priority>3</priority>
		<example>
    <![CDATA[
public class MyClass {

	public MyClass() {}			// this is OK because it is a constructor
	
	public void MyClass() {}	// this is bad because it is a method
}
    ]]>
       </example>
	</rule>

	<rule name="SuspiciousHashcodeMethodName" since="1.5"
		message="The method name and return type are suspiciously close to hashCode()"
		class="net.sourceforge.pmd.lang.java.rule.naming.SuspiciousHashcodeMethodNameRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#SuspiciousHashcodeMethodName">
		<description>
The method name and return type are suspiciously close to hashCode(), which may denote an intention
to override the hashCode() method.
       </description>
		<priority>3</priority>
		<example>
    <![CDATA[
public class Foo {
	public int hashcode() {	// oops, this probably was supposed to be 'hashCode'
	
	}
}
    ]]>
       </example>
	</rule>

	<rule name="SuspiciousConstantFieldName" language="java" since="2.0"
		message="The field name indicates a constant but its modifiers do not"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#SuspiciousConstantFieldName">
		<description>
Field names using all uppercase characters - Sun's Java naming conventions indicating constants - should
be declared as final.
       </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Interface='false']
 /ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
  [@Final='false']
  [VariableDeclarator/VariableDeclaratorId[upper-case(@Image)=@Image]]
 ]]>
                </value>
			</property>
		</properties>
		<example>
    <![CDATA[
public class Foo {
 // this is bad, since someone could accidentally
 // do PI = 2.71828; which is actually e
 // final double PI = 3.16; is ok
  double PI = 3.16;
}
    ]]>
       </example>
	</rule>

	<rule name="SuspiciousEqualsMethodName" language="java" since="2.0"
		message="The method name and parameter number are suspiciously close to equals(Object)"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#SuspiciousEqualsMethodName">
		<description>
The method name and parameter number are suspiciously close to equals(Object), which can denote an
intention to override the equals(Object) method.
        </description>
		<priority>2</priority>
		<properties>
			<property name="xpath">
				<value><![CDATA[
//MethodDeclarator[@Image = 'equals']
[   
    (count(FormalParameters/*) = 1
    and not (FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
        [@Image = 'Object' or @Image = 'java.lang.Object'])
    or not (../ResultType/Type/PrimitiveType[@Image = 'boolean'])
    )  or  (
    count(FormalParameters/*) = 2
    and ../ResultType/Type/PrimitiveType[@Image = 'boolean']
    and FormalParameters//ClassOrInterfaceType[@Image = 'Object' or @Image = 'java.lang.Object']
    )
]
| //MethodDeclarator[@Image = 'equal']
[
    count(FormalParameters/*) = 1
    and FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
        [@Image = 'Object' or @Image = 'java.lang.Object']
]           
]]>
                    </value>
			</property>
		</properties>
		<example><![CDATA[
public class Foo {
   public int equals(Object o) {
     // oops, this probably was supposed to be boolean equals
   }
   public boolean equals(String s) {
     // oops, this probably was supposed to be equals(Object)
   }
   public boolean equals(Object o1, Object o2) {
     // oops, this probably was supposed to be equals(Object)
   }
}
        ]]></example>
	</rule>

	<rule name="AvoidFieldNameMatchingTypeName" since="3.0"
		message="It is somewhat confusing to have a field name matching the declaring class name"
		class="net.sourceforge.pmd.lang.java.rule.naming.AvoidFieldNameMatchingTypeNameRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#AvoidFieldNameMatchingTypeName">
		<description>
It is somewhat confusing to have a field name matching the declaring class name.
This probably means that type and/or field names should be chosen more carefully.
      </description>
		<priority>3</priority>
		<example>
<![CDATA[
public class Foo extends Bar {
	int foo;	// There is probably a better name that can be used
}
]]>
      </example>
	</rule>

	<rule name="AvoidFieldNameMatchingMethodName" since="3.0"
		message="Field {0} has the same name as a method"
		class="net.sourceforge.pmd.lang.java.rule.naming.AvoidFieldNameMatchingMethodNameRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#AvoidFieldNameMatchingMethodName">
		<description>
It can be confusing to have a field name with the same name as a method. While this is permitted, 
having information (field) and actions (method) is not clear naming. Developers versed in 
Smalltalk often prefer this approach as the methods denote accessor methods.
      </description>
		<priority>3</priority>
		<example>
<![CDATA[
public class Foo {
	Object bar;
	// bar is data or an action or both?
	void bar() {
	}
}
]]>
      </example>
	</rule>



	<rule name="NoPackage" language="java" since="3.3"
		message="All classes and interfaces must belong to a named package"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#NoPackage">
		<description>
Detects when a class or interface does not have a package definition.
    </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                  <![CDATA[
//ClassOrInterfaceDeclaration[count(preceding::PackageDeclaration) = 0]
                  ]]>
              </value>
			</property>
		</properties>
		<example>
<![CDATA[
// no package declaration
public class ClassInDefaultPackage {
}
]]>
    </example>
	</rule>

	<rule name="PackageCase" language="java" since="3.3"
		message="Package name contains upper case characters" class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#PackageCase">
		<description>
Detects when a package definition contains uppercase characters.
        </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                      <![CDATA[
//PackageDeclaration/Name[lower-case(@Image)!=@Image]
                      ]]>
                  </value>
			</property>
		</properties>
		<example>
    <![CDATA[
package com.MyCompany;  // should be lowercase name

public class SomeClass {
}
    ]]>
        </example>
	</rule>

	<rule name="MisleadingVariableName" language="java" since="3.4"
		message="Avoid naming non-fields with the prefix 'm_'" class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#MisleadingVariableName">
		<description>
Detects when a non-field has a name starting with 'm_'.  This usually denotes a field and could be confusing.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                    <![CDATA[
//VariableDeclaratorId
[starts-with(@Image, 'm_')]
[not (../../../FieldDeclaration)]
                    ]]>
                </value>
			</property>
		</properties>
		<example>
  <![CDATA[
public class Foo {
    private int m_foo; // OK
    public void bar(String m_baz) {  // Bad
      int m_boz = 42; // Bad
    }
}
  ]]>
      </example>
	</rule>

	<rule name="BooleanGetMethodName" language="java" since="4.0"
		message="A 'getX()' method which returns a boolean should be named 'isX()'"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#BooleanGetMethodName">
		<description>
Methods that return boolean results should be named as predicate statements to denote this.
I.e, 'isReady()', 'hasValues()', 'canCommit()', 'willFail()', etc.   Avoid the use of the 'get'
prefix for these methods.
        </description>
		<priority>4</priority>
		<properties>
			<property name="xpath">
				<value>
                    <![CDATA[
//MethodDeclaration[
MethodDeclarator[count(FormalParameters/FormalParameter) = 0 or $checkParameterizedMethods = 'true']
                [starts-with(@Image, 'get')]
and
ResultType/Type/PrimitiveType[@Image = 'boolean']
]
]]>
                </value>
			</property>
			<property name="checkParameterizedMethods" type="Boolean"
				description="Check parameterized methods" value="false" />
		</properties>
		<example>
            <![CDATA[
public boolean getFoo(); 	// bad
public boolean isFoo(); 	// ok
public boolean getFoo(boolean bar); // ok, unless checkParameterizedMethods=true
     ]]></example>
	</rule>

	<rule name="ShortClassName" language="java" since="5.0"
		message="A Classname should have a minimum of five characters" class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#ShortClassName">
		<description>
        	<![CDATA[
Classnames with fewer than five characters are not recommended.
			]]>
        </description>
		<priority>4</priority>
		<properties>
			<property name="xpath">
				<value>
                      <![CDATA[
//ClassOrInterfaceDeclaration[string-length(@Image) < 5]
                      ]]>
                  </value>
			</property>
		</properties>
		<example>
    <![CDATA[
public class Foo {
}
    ]]>
        </example>
	</rule>

	<rule name="GenericsNaming" language="java" since="4.2.6"
		message="Generics names should be a one letter long and upper case."
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/naming.html#GenericsNaming">
		<description>
Names for references to generic values should be limited to a single uppercase letter.
        </description>
		<priority>4</priority>
		<properties>
			<property name="xpath">
				<value>
                    <![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/TypeParameters/TypeParameter[
  string-length(@Image) > 1 
  or
  string:upper-case(@Image) != @Image
]
]]>
                </value>
			</property>
		</properties>
		<example>
            <![CDATA[
public interface GenericDao<E extends BaseModel, K extends Serializable> extends BaseDao {
   // This is ok...
}

public interface GenericDao<E extends BaseModel, K extends Serializable> {
   // Also this
}

public interface GenericDao<e extends BaseModel, K extends Serializable> {
   // 'e' should be an 'E'
}

public interface GenericDao<EF extends BaseModel, K extends Serializable> {
   // 'EF' is not ok.
}
     ]]></example>
	</rule>

	<!-- Cloing -->

	<rule name="ProperCloneImplementation" language="java" since="1.4"
		message="Object clone() should be implemented with super.clone()"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/clone.html#ProperCloneImplementation">
		<description>
Object clone() should be implemented with super.clone().
     </description>
		<priority>2</priority>
		<properties>
			<property name="xpath">
				<value>
                 <![CDATA[
//MethodDeclarator
[@Image = 'clone']
[count(FormalParameters/*) = 0]
[count(../Block//*[
    (self::AllocationExpression) and
    (./ClassOrInterfaceType/@Image = ancestor::
ClassOrInterfaceDeclaration[1]/@Image)
  ])> 0
]
                ]]>
             </value>
			</property>
		</properties>
		<example>
 <![CDATA[
class Foo{
    public Object clone(){
        return new Foo(); // This is bad
    }
}
]]>
     </example>
	</rule>

	<rule name="CloneThrowsCloneNotSupportedException" language="java"
		since="1.9" message="clone() method should throw CloneNotSupportedException"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/clone.html#CloneThrowsCloneNotSupportedException">
		<description>
The method clone() should throw a CloneNotSupportedException.
         </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                     <![CDATA[
//MethodDeclaration
[
MethodDeclarator/@Image = 'clone'
and count(MethodDeclarator/FormalParameters/*) = 0
and count(NameList/Name[contains
(@Image,'CloneNotSupportedException')]) = 0
]
[
../../../../ClassOrInterfaceDeclaration[@Final = 'false']
]
                     ]]>
                 </value>
			</property>
		</properties>
		<example>
             <![CDATA[
 public class MyClass implements Cloneable{
     public Object clone() { // will cause an error
          MyClass clone = (MyClass)super.clone();
          return clone;
     }
 }
    ]]>
         </example>
	</rule>

	<rule name="CloneMethodMustImplementCloneable" language="java"
		since="1.9"
		message="clone() method should be implemented only if implementing Cloneable interface"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/clone.html#CloneMethodMustImplementCloneable">
		<description>
The method clone() should only be implemented if the class implements the Cloneable interface with the exception of a final method that only throws CloneNotSupportedException.
        </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                    <![CDATA[
//ClassOrInterfaceDeclaration
[not(./ImplementsList/ClassOrInterfaceType
[@Image='Cloneable'])]
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
[MethodDeclaration
[MethodDeclarator[@Image
= 'clone' and count(FormalParameters/*) = 0]]
[not((../MethodDeclaration[@Final = 'true'] or ancestor::ClassOrInterfaceDeclaration[1][@Final = 'true'])
and Block[count(BlockStatement)=1]
/BlockStatement/Statement/ThrowStatement/Expression
/PrimaryExpression/PrimaryPrefix/AllocationExpression
/ClassOrInterfaceType[@Image = 'CloneNotSupportedException'])]]

                    ]]>
                </value>
			</property>
		</properties>
		<example>
            <![CDATA[
public class MyClass {
 public Object clone() throws CloneNotSupportedException {
  return foo;
 }
}
   ]]>
        </example>
	</rule>
	<!-- JUnit -->
	<rule name="JUnitStaticSuite" language="java" since="1.0"
		message="You have a suite() method that is not both public and static, so JUnit won't call it to get your TestSuite.  Is that what you wanted to do?"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#JUnitStaticSuite">
		<description>
The suite() method in a JUnit test needs to be both public and static.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                <![CDATA[
//MethodDeclaration[not(@Static='true') or not(@Public='true')]
[MethodDeclarator/@Image='suite']
[MethodDeclarator/FormalParameters/@ParameterCount=0]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[pmd-java:typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[pmd-java:typeof(@Image, 'org.junit.Test', 'Test')]]]
                ]]>
            </value>
			</property>
		</properties>
		<example>
  <![CDATA[
import junit.framework.*;

public class Foo extends TestCase {
   public void suite() {}         // oops, should be static
   private static void suite() {} // oops, should be public
}
  ]]>
      </example>
	</rule>

	<rule name="JUnitSpelling" language="java" since="1.0"
		message="You may have misspelled a JUnit framework method (setUp or tearDown)"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#JUnitSpelling">
		<description>
Some JUnit framework methods are easy to misspell.
    </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
              <![CDATA[
//MethodDeclarator[(not(@Image = 'setUp')
 and translate(@Image, 'SETuP', 'setUp') = 'setUp')
 or (not(@Image = 'tearDown')
 and translate(@Image, 'TEARdOWN', 'tearDown') = 'tearDown')]
 [FormalParameters[count(*) = 0]]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[pmd-java:typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[pmd-java:typeof(@Image, 'org.junit.Test', 'Test')]]]
              ]]>
          </value>
			</property>
		</properties>
		<example>
<![CDATA[
import junit.framework.*;

public class Foo extends TestCase {
   public void setup() {}    // oops, should be setUp
   public void TearDown() {} // oops, should be tearDown
}
]]>
    </example>
	</rule>

	<rule name="JUnitAssertionsShouldIncludeMessage" since="1.04"
		message="JUnit assertions should include a message"
		class="net.sourceforge.pmd.lang.java.rule.junit.JUnitAssertionsShouldIncludeMessageRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#JUnitAssertionsShouldIncludeMessage">
		<description>
JUnit assertions should include an informative message - i.e., use the three-argument version of 
assertEquals(), not the two-argument version.
      </description>
		<priority>3</priority>
		<example>
  <![CDATA[
public class Foo extends TestCase {
 public void testSomething() {
  assertEquals("foo", "bar");
  // Use the form:
  // assertEquals("Foo does not equals bar", "foo", "bar");
  // instead
 }
}
  ]]>
      </example>
	</rule>

	<rule name="JUnitTestsShouldIncludeAssert" since="2.0"
		message="JUnit tests should include assert() or fail()"
		class="net.sourceforge.pmd.lang.java.rule.junit.JUnitTestsShouldIncludeAssertRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#JUnitTestsShouldIncludeAssert">
		<description>
JUnit tests should include at least one assertion.  This makes the tests more robust, and using assert 
with messages provide the developer a clearer idea of what the test does.
        </description>
		<priority>3</priority>
		<example>
    <![CDATA[
public class Foo extends TestCase {
   public void testSomething() {
      Bar b = findBar();
   // This is better than having a NullPointerException
   // assertNotNull("bar not found", b);
   b.work();
   }
}
    ]]>
        </example>
	</rule>

	<rule name="TestClassWithoutTestCases" since="3.0"
		message="This class name ends with 'Test' but contains no test cases"
		class="net.sourceforge.pmd.lang.java.rule.junit.TestClassWithoutTestCasesRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#TestClassWithoutTestCases">
		<description>
Test classes end with the suffix Test. Having a non-test class with that name is not a good practice, 
since most people will assume it is a test case. Test classes have test methods named testXXX.
      </description>
		<priority>3</priority>
		<example>
<![CDATA[
//Consider changing the name of the class if it is not a test
//Consider adding test methods if it is a test
public class CarTest {
   public static void main(String[] args) {
    // do something
   }
   // code
}
]]>
      </example>
	</rule>

	<rule name="UnnecessaryBooleanAssertion" language="java" since="3.0"
		message="assertTrue(true) or similar statements are unnecessary"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#UnnecessaryBooleanAssertion">
		<description>
A JUnit test assertion with a boolean literal is unnecessary since it always will evaluate to the same thing.
Consider using flow control (in case of assertTrue(false) or similar) or simply removing
statements like assertTrue(true) and assertFalse(false).  If you just want a test to halt after finding
an error, use the fail() method and provide an indication message of why it did.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
    <![CDATA[
//StatementExpression
[
PrimaryExpression/PrimaryPrefix/Name[@Image='assertTrue' or  @Image='assertFalse']
and
PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression
[PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral
or
UnaryExpressionNotPlusMinus[@Image='!']
/PrimaryExpression/PrimaryPrefix[Literal/BooleanLiteral or Name[count(../../*)=1]]]
]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[pmd-java:typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[pmd-java:typeof(@Image, 'org.junit.Test', 'Test')]]]
]]>
              </value>
			</property>
		</properties>
		<example>
<![CDATA[
public class SimpleTest extends TestCase {
	public void testX() {
		assertTrue(true);		 // serves no real purpose
	}
}
]]>
          </example>
	</rule>

	<rule name="UseAssertEqualsInsteadOfAssertTrue" language="java"
		since="3.1" message="Use assertEquals(x, y) instead of assertTrue(x.equals(y))"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#UseAssertEqualsInsteadOfAssertTrue">
		<description>
This rule detects JUnit assertions in object equality. These assertions should be made by more specific methods, like assertEquals.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                <![CDATA[
//PrimaryExpression[
    PrimaryPrefix/Name[@Image = 'assertTrue']
][
    PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name
    [ends-with(@Image, '.equals')]
]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[pmd-java:typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[pmd-java:typeof(@Image, 'org.junit.Test', 'Test')]]]
 ]]>
            </value>
			</property>
		</properties>
		<example>
<![CDATA[
public class FooTest extends TestCase {
	void testCode() {
		Object a, b;
		assertTrue(a.equals(b)); 					// bad usage
		assertEquals(?a should equals b?, a, b);	// good usage
	}
}
]]>
      </example>
	</rule>

	<rule name="UseAssertSameInsteadOfAssertTrue" language="java"
		since="3.1"
		message="Use assertSame(x, y) instead of assertTrue(x==y), or assertNotSame(x,y) vs assertFalse(x==y)"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#UseAssertSameInsteadOfAssertTrue">
		<description>
This rule detects JUnit assertions in object references equality. These assertions should be made 
by more specific methods, like assertSame, assertNotSame.
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                <![CDATA[
//PrimaryExpression[
    PrimaryPrefix/Name
     [@Image = 'assertTrue' or @Image = 'assertFalse']
]
[PrimarySuffix/Arguments
 /ArgumentList/Expression
 /EqualityExpression[count(.//NullLiteral) = 0]]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[pmd-java:typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[pmd-java:typeof(@Image, 'org.junit.Test', 'Test')]]]
 ]]>
            </value>
			</property>
		</properties>
		<example>
<![CDATA[
public class FooTest extends TestCase {
 void testCode() {
  Object a, b;
  assertTrue(a == b); // bad usage
  assertSame(a, b);  // good usage
 }
}
]]>
      </example>
	</rule>

	<rule name="UseAssertNullInsteadOfAssertTrue" language="java"
		since="3.5"
		message="Use assertNull(x) instead of assertTrue(x==null), or assertNotNull(x) vs assertFalse(x==null)"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#UseAssertNullInsteadOfAssertTrue">
		<description>
This rule detects JUnit assertions in object references equality. These assertions should be made by 
more specific methods, like assertNull, assertNotNull.
       </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
                 <![CDATA[
//PrimaryExpression[
 PrimaryPrefix/Name[@Image = 'assertTrue' or @Image = 'assertFalse']
][
 PrimarySuffix/Arguments/ArgumentList[
  Expression/EqualityExpression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral
 ]
]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[pmd-java:typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[pmd-java:typeof(@Image, 'org.junit.Test', 'Test')]]]
  ]]>
             </value>
			</property>
		</properties>
		<example>
 <![CDATA[
 public class FooTest extends TestCase {
  void testCode() {
   Object a = doSomething();
   assertTrue(a==null); // bad usage
   assertNull(a);  // good usage
   assertTrue(a != null); // bad usage
   assertNotNull(a);  // good usage
  }
 }
 ]]>
       </example>
	</rule>

	<rule name="SimplifyBooleanAssertion" language="java" since="3.6"
		message="assertTrue(!expr) can be replaced by assertFalse(expr)"
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#SimplifyBooleanAssertion">
		<description>
Avoid negation in an assertTrue or assertFalse test.

For example, rephrase:

   assertTrue(!expr);
   
as:

   assertFalse(expr);
      </description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
    <![CDATA[
//StatementExpression
[
.//Name[@Image='assertTrue' or  @Image='assertFalse']
and
PrimaryExpression/PrimarySuffix/Arguments/ArgumentList
 /Expression/UnaryExpressionNotPlusMinus[@Image='!']
/PrimaryExpression/PrimaryPrefix
]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[pmd-java:typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[pmd-java:typeof(@Image, 'org.junit.Test', 'Test')]]]
]]>
              </value>
			</property>
		</properties>
		<example>
<![CDATA[
public class SimpleTest extends TestCase {
   public void testX() {
     assertTrue("not empty", !r.isEmpty()); // replace with assertFalse("not empty", r.isEmpty())
     assertFalse(!r.isEmpty()); // replace with assertTrue(r.isEmpty())
   }
}
]]>
          </example>
	</rule>
	<rule name="JUnitTestContainsTooManyAsserts" language="java"
		since="5.0"
		message="JUnit tests should not contain more than ${maximumAsserts} assert(s)."
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#JUnitTestContainsTooManyAsserts">
		<description>
JUnit tests should not contain too many asserts.  Many asserts are indicative of a complex test, for which 
it is harder to verify correctness.  Consider breaking the test scenario into multiple, shorter test scenarios.  
Customize the maximum number of assertions used by this Rule to suit your needs.
		</description>
		<priority>3</priority>
		<properties>
			<property name="maximumAsserts" type="Integer" min="1" max="1000"
				description="Maximum number of Asserts in a test method" value="1" />
			<property name="xpath">
				<value>
<![CDATA[
//MethodDeclarator[(@Image[fn:matches(.,'^test')] or ../../Annotation/MarkerAnnotation/Name[@Image='Test']) and count(..//PrimaryPrefix/Name[@Image[fn:matches(.,'^assert')]]) > $maximumAsserts]
]]>
				</value>
			</property>
		</properties>
		<example>
<![CDATA[
public class MyTestCase extends TestCase {
	// Ok
	public void testMyCaseWithOneAssert() {
		boolean myVar = false;		
		assertFalse("should be false", myVar);
	}

	// Bad, too many asserts (assuming max=1)
	public void testMyCaseWithMoreAsserts() {
		boolean myVar = false;		
		assertFalse("myVar should be false", myVar);
		assertEquals("should equals false", false, myVar);
	}
}
]]>
		</example>
	</rule>
	<rule name="UseAssertTrueInsteadOfAssertEquals" language="java"
		since="5.0"
		message="Use assertTrue(x)/assertFalse(x) instead of assertEquals(true, x)/assertEquals(false, x)."
		class="net.sourceforge.pmd.lang.rule.XPathRule"
		externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/junit.html#UseAssertTrueInsteadOfAssertEquals">
		<description>
When asserting a value is the same as a boolean literal, use assertTrue/assertFalse, instead of assertEquals.
		</description>
		<priority>3</priority>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//PrimaryExpression[PrimaryPrefix/Name[@Image = 'assertEquals']][PrimarySuffix/Arguments/ArgumentList//Expression/PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral]
]]>
			</value>
			</property>
		</properties>
		<example>
<![CDATA[
public class MyTestCase extends TestCase {
	public void testMyCase() {
		boolean myVar = true;
		// Ok
		assertTrue("myVar is true", myVar);
		// Bad
		assertEquals("myVar is true", true, myVar);
		// Bad
		assertEquals("myVar is false", false, myVar);
	}
}
]]>
		</example>
	</rule>

	

	

	<rule name="SwitchStmtsShouldHaveDefault" message="Switch statements should have a default label"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java" 
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SwitchStmtsShouldHaveDefault">
		<description>
Switch statements should have a default label.
    </description>
		<properties>
			<property name="xpath">
				<value>
                  <![CDATA[
//SwitchStatement[not(SwitchLabel[@Default='true'])]
                  ]]>
              </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
<![CDATA[
public class Foo {
 public void bar() {
  int x = 2;
  switch (x) {
   case 2: int j = 8;
  }
 }
}
]]>
    </example>
	</rule>

	<rule name="SwitchDensity"
    		 since="1.02"
          message="A high ratio of statements to labels in a switch statement.  Consider refactoring."
          class="net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/design.html#SwitchDensity">
      <description>
A high ratio of statements to labels in a switch statement implies that the switch statement 
is overloaded.  Consider moving the statements into new methods or creating subclasses based 
on the switch variable.
      </description>
        <priority>3</priority>
      <example>
 <![CDATA[
public class Foo {
  public void bar(int x) {
    switch (x) {
      case 1: {
        // lots of statements
        break;
      } case 2: {
        // lots of statements
        break;
      }
    }
  }
}
 ]]>
      </example>
    </rule>

	<rule name="FinalFieldCouldBeStatic" message="This final field could be made static"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#FinalFieldCouldBeStatic">
		<description>
If a final field is assigned to a compile-time constant, it could be
made static, thus saving overhead in each object at runtime.
      </description>
		<properties>
			<property name="xpath">
				<value>
                    <![CDATA[
//FieldDeclaration
 [@Final='true' and @Static='false']
 [not (../../../../ClassOrInterfaceDeclaration[@Interface='true'])]
   /VariableDeclarator/VariableInitializer/Expression
    /PrimaryExpression/PrimaryPrefix/Literal
                    ]]>
                </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
  <![CDATA[
public class Foo {
 public final int BAR = 42; // this could be static and save some space
}
  ]]>
      </example>
	</rule>

	<rule name="CloseResource"
  		  since="1.2.2"
        message="Ensure that resources like this {0} object are closed after use"
        class="net.sourceforge.pmd.lang.java.rule.design.CloseResourceRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/design.html#CloseResource">
    <description>
Ensure that resources (like Connection, Statement, and ResultSet objects) are always closed after use.
    </description>
    <priority>3</priority>
    <example>
<![CDATA[
public class Bar {
  public void foo() {
    Connection c = pool.getConnection();
    try {
      // do stuff
    } catch (SQLException ex) {
     // handle exception
    } finally {
      // oops, should close the connection using 'close'!
      // c.close();
    }
  }
}
]]>
    </example>
  </rule>

	<rule name="NonStaticInitializer" message="Non-static initializers are confusing"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#NonStaticInitializer">
		<description>
A nonstatic initializer block will be called any time a constructor
is invoked (just prior to invoking the constructor).  While this
is a valid language construct, it is rarely used and is confusing.
       </description>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//Initializer[@Static='false']
]]>
                 </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
   <![CDATA[
public class MyClass {
 // this block gets run before any call to a constructor
 {
  System.out.println("I am about to construct myself");
 }
}
   ]]>
       </example>
	</rule>

	<rule name="OptimizableToArrayCall" message="This call to Collection.toArray() may be optimizable"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#OptimizableToArrayCall">
		<description>
A call to Collection.toArray can use the Collection's size vs an empty Array of the desired type.
      </description>
		<properties>
			<property name="xpath">
				<value>
                  <![CDATA[
//PrimaryExpression
[PrimaryPrefix/Name[ends-with(@Image, 'toArray')]]
[
PrimarySuffix/Arguments/ArgumentList/Expression
 /PrimaryExpression/PrimaryPrefix/AllocationExpression
 /ArrayDimsAndInits/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image='0']
]

                  ]]>
              </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
  <![CDATA[
class Foo {
 void bar(Collection x) {
   // A bit inefficient
   x.toArray(new Foo[0]);
   // Much better; this one sizes the destination array, avoiding
   // a reflection call in some Collection implementations
   x.toArray(new Foo[x.size()]);
 }
}
  ]]>
      </example>
	</rule>

	<rule name="BadComparison" message="Avoid equality comparisons with Double.NaN"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#BadComparison">
		<description>
Avoid equality comparisons with Double.NaN - these are likely to be logic errors.
      </description>
		<properties>
			<property name="xpath">
				<value>
                  <![CDATA[
//EqualityExpression[@Image='==']
 /PrimaryExpression/PrimaryPrefix
 /Name[@Image='Double.NaN' or @Image='Float.NaN']
                  ]]>
              </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
  <![CDATA[
public class Bar {
 boolean x = (y == Double.NaN);
}
  ]]>
      </example>
	</rule>

	<rule name="EqualsNull" message="Avoid using equals() to compare against null"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#EqualsNull">
		<description>
Inexperienced programmers sometimes confuse comparison concepts
and use equals() to compare to null.
        </description>
		<properties>
			<property name="xpath">
				<value>
    <![CDATA[
//PrimaryExpression
 [
PrimaryPrefix/Name[ends-with(@Image, 'equals')]
or
PrimarySuffix[ends-with(@Image, 'equals')]
]
[PrimarySuffix/Arguments/ArgumentList[count(Expression)=1]
  /Expression/PrimaryExpression/PrimaryPrefix
   /Literal/NullLiteral]
    ]]>
                </value>
			</property>
		</properties>
		<priority>1</priority>
		<example>
       <![CDATA[
class Bar {
   void foo() {
       String x = "foo";
       if (x.equals(null)) { // bad!
        doSomething();
       }
   }
}
    ]]>
        </example>
	</rule>

	<rule name="InstantiationToGetClass"
		message="Avoid instantiating an object just to call getClass() on it; use the .class public member instead"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#InstantiationToGetClass">
		<description>
Avoid instantiating an object just to call getClass() on it; use the .class public member instead.
      </description>
		<example>
    <![CDATA[
public class Foo {
 // Replace this
 Class c = new String().getClass();
 // with this:
 Class c = String.class;
}
    ]]>
        </example>
		<priority>4</priority>
		<properties>
			<property name="xpath">
				<value>
                <![CDATA[
//PrimarySuffix
 [@Image='getClass']
 [parent::PrimaryExpression
  [PrimaryPrefix/AllocationExpression]
  [count(PrimarySuffix) = 2]
 ]
     ]]>
            </value>
			</property>
		</properties>
	</rule>

	<rule name="IdempotentOperations"
    		 since="2.0"
          message="Avoid idempotent operations (like assigning a variable to itself)."
          class="net.sourceforge.pmd.lang.java.rule.design.IdempotentOperationsRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/design.html#IdempotentOperations">
      <description>
Avoid idempotent operations - they have no effect.
      </description>
        <priority>3</priority>

      <example>
      <![CDATA[
public class Foo {
 public void bar() {
  int x = 2;
  x = x;
 }
}
      ]]>
      </example>
    </rule>

	
	<rule name="ImmutableField"
    		 since="2.0"
          message="Private field ''{0}'' could be made final; it is only initialized in the declaration or constructor."
          class="net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/design.html#ImmutableField">
      <description>
Identifies private fields whose values never change once they are initialized either in the declaration 
of the field or by a constructor.  This helps in converting existing classes to becoming immutable ones.
      </description>
        <priority>3</priority>

      <example>
  <![CDATA[
public class Foo {
  private int x; // could be final
  public Foo() {
      x = 7;
  }
  public void foo() {
     int a = x + 2;
  }
}
  ]]>
      </example>
    </rule>

	

	<rule name="AvoidProtectedFieldInFinalClass"
		message="Avoid protected fields in a final class.  Change to private or package access."
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidProtectedFieldInFinalClass">
		<description>
Do not use protected fields in final classes since they cannot be subclassed.
Clarify your intent by using private or package access modifiers instead.
         </description>
		<properties>
			<property name="xpath">
				<value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Final='true']
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/FieldDeclaration[@Protected='true']
 ]]>
                 </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
<![CDATA[
public final class Bar {
 private int x;
 protected int y;  // <-- Bar cannot be subclassed, so is y really private or package visible???
 Bar() {}
}
 ]]>
         </example>
	</rule>

	<rule name="AssignmentToNonFinalStatic"
     		  since="2.2"
           message="Possible unsafe assignment to a non-final static field in a constructor."
           class="net.sourceforge.pmd.lang.java.rule.design.AssignmentToNonFinalStaticRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/design.html#AssignmentToNonFinalStatic">
       <description>
Identifies a possible unsafe usage of a static field.
       </description>
         <priority>3</priority>
       <example>
   <![CDATA[
public class StaticField {
   static int x;
   public FinalFields(int y) {
    x = y; // unsafe
   }
}
   ]]>
       </example>
     </rule>

	<rule name="MissingStaticMethodInNonInstantiatableClass"
		message="Class cannot be instantiated and does not provide any static methods or fields"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#MissingStaticMethodInNonInstantiatableClass">
		<description>
A class that has private constructors and does not have any static methods or fields cannot be used.
      </description>
		<properties>
			<property name="xpath">
				<value>
    <![CDATA[
//ClassOrInterfaceDeclaration[@Nested='false'][
( count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration)>0
  and count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration) = count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Private='true']) )
and
count(.//MethodDeclaration[@Static='true'])=0
and
count(.//FieldDeclaration[@Private='false'][@Static='true'])=0
]
    ]]>
              </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
<![CDATA[
/* This class is unusable, since it cannot be
 instantiated (private constructor),
 and no static method can be called.
 */
public class Foo {
 private Foo() {}
 void foo() {}
}

]]>
      </example>
	</rule>

	<rule name="AvoidSynchronizedAtMethodLevel"
		message="Use block level rather than method level synchronization"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidSynchronizedAtMethodLevel">
		<description>
  Method level synchronization can backfire when new code is added to the method.  Block-level
  synchronization helps to ensure that only the code that needs synchronization gets it.
      </description>
		<properties>
			<property name="xpath">
				<value>
    <![CDATA[
//MethodDeclaration[@Synchronized='true']
    ]]>
              </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
<![CDATA[
public class Foo {
 // Try to avoid this
 synchronized void foo() {
 }
 // Prefer this:
 void bar() {
  synchronized(this) {
  }
 }
}
]]>
      </example>
	</rule>

	<rule name="AvoidInstanceofChecksInCatchClause"
		message="An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type."
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidInstanceofChecksInCatchClause">
		<description>
Each caught exception type should be handled in its own catch clause.
      </description>
		<properties>
			<property name="xpath">
				<value>
    <![CDATA[
//CatchStatement/FormalParameter
 /following-sibling::Block//InstanceOfExpression/PrimaryExpression/PrimaryPrefix
  /Name[
   @Image = ./ancestor::Block/preceding-sibling::FormalParameter
    /VariableDeclaratorId/@Image
  ]
    ]]>
              </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
<![CDATA[
try { // Avoid this
 // do something
} catch (Exception ee) {
 if (ee instanceof IOException) {
  cleanup();
 }
}
try {  // Prefer this:
 // do something
} catch (IOException ee) {
 cleanup();
}
]]>
      </example>
	</rule>

	<rule name="AbstractClassWithoutAbstractMethod"
		message="This abstract class does not have any abstract methods"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AbstractClassWithoutAbstractMethod">
		<description>
The abstract class does not contain any abstract methods. An abstract class suggests
an incomplete implementation, which is to be completed by subclasses implementing the
abstract methods. If the class is intended to be used as a base class only (not to be instantiated
direcly) a protected constructor can be provided prevent direct instantiation.
      </description>
		<properties>
			<property name="xpath">
				<value><![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true'
  and count( .//MethodDeclaration[@Abstract='true'] )=0 ]
  [count(ImplementsList)=0]
              ]]>
              </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
<![CDATA[
public abstract class Foo {
 void int method1() { ... }
 void int method2() { ... }
 // consider using abstract methods or removing
 // the abstract modifier and adding protected constructors
}
]]>
      </example>
	</rule>

	<rule name="SimplifyConditional" message="No need to check for null before an instanceof"
		class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimplifyConditional">
		<description>
No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.
           </description>
		<properties>
			<property name="xpath">
				<value>
                      <![CDATA[
//Expression
 [ConditionalOrExpression
 [EqualityExpression[@Image='==']
  //NullLiteral
  and
  UnaryExpressionNotPlusMinus
   [@Image='!']//InstanceOfExpression[PrimaryExpression
     //Name/@Image = ancestor::ConditionalOrExpression/EqualityExpression
      /PrimaryExpression/PrimaryPrefix/Name/@Image]]
or
ConditionalAndExpression
 [EqualityExpression[@Image='!=']//NullLiteral
 and
InstanceOfExpression
 [PrimaryExpression[count(PrimarySuffix[@ArrayDereference='true'])=0]
  //Name/@Image = ancestor::ConditionalAndExpression
   /EqualityExpression/PrimaryExpression/PrimaryPrefix/Name/@Image]]]
 ]]>
                  </value>
			</property>
		</properties>
		<priority>3</priority>
		<example>
      <![CDATA[
class Foo {
 void bar(Object x) {
  if (x != null && x instanceof Bar) {
   // just drop the "x != null" check
  }
 }
}      ]]>
           </example>
	</rule>


	<rule  name="CompareObjectsWithEquals"
  since="3.2"
  message="Use equals() to compare object references."
  class="net.sourceforge.pmd.lang.java.rule.design.CompareObjectsWithEqualsRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/design.html#CompareObjectsWithEquals">
  <description>
Use equals() to compare object references; avoid comparing them with ==.
  </description>
  <priority>3</priority>
  <example>
<![CDATA[
class Foo {
  boolean bar(String a, String b) {
    return a == b;
  }
}

]]>
  </example>
</rule>
	
	<rule  name="PositionLiteralsFirstInComparisons"
  message="Position literals first in String comparisons"
  class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#PositionLiteralsFirstInComparisons">
  <description>
 Position literals first in String comparisons - that way if the String is null you won't get a NullPointerException, it'll just return false.
  </description>
      <properties>
        <property name="xpath">
          <value><![CDATA[
//PrimaryExpression[PrimaryPrefix[Name[ends-with(@Image, '.equals')]][..//Literal]]
    [not(ancestor::Expression/ConditionalAndExpression//EqualityExpression[@Image='!=']//NullLiteral)]
    [not(ancestor::Expression/ConditionalOrExpression//EqualityExpression[@Image='==']//NullLiteral)]
          ]]></value>
        </property>
      </properties>  <priority>3</priority>
  <example>
<![CDATA[
class Foo {
 boolean bar(String x) {
  return x.equals("2"); // should be "2".equals(x)
 }
}

]]>
  </example>
</rule>

<rule name="UnnecessaryLocalBeforeReturn"
          since="3.3"
          message="Consider simply returning the value vs storing it in local variable ''{0}''"
          class="net.sourceforge.pmd.lang.java.rule.design.UnnecessaryLocalBeforeReturnRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/design.html#UnnecessaryLocalBeforeReturn">
      <description>
Avoid the creation of unnecessary local variables
      </description>
        <priority>3</priority>
      <example>
  <![CDATA[
public class Foo {
   public int foo() {
     int x = doSomething();
     return x;  // instead, just 'return doSomething();'
   }
}
  ]]>
      </example>
    </rule>
    
    <rule name="NonThreadSafeSingleton"
    since="3.4"
    message="Singleton is not thread safe"
    class="net.sourceforge.pmd.lang.java.rule.design.NonThreadSafeSingletonRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/design.html#NonThreadSafeSingleton">
        <description>
Non-thread safe singletons can result in bad state changes. Eliminate
static singletons if possible by instantiating the object directly. Static
singletons are usually not needed as only a single instance exists anyway.
Other possible fixes are to synchronize the entire method or to use an
initialize-on-demand holder class (do not use the double-check idiom).

See Effective Java, item 48.
        </description>
        <priority>3</priority>
        <example><![CDATA[
private static Foo foo = null;

//multiple simultaneous callers may see partially initialized objects
public static Foo getFoo() {
    if (foo==null)
        foo = new Foo();
    return foo;
}
        ]]></example>
    </rule>
    
    <rule name="UncommentedEmptyMethod"
          message="Document empty method"
          class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UncommentedEmptyMethod">
      <description>
Uncommented Empty Method finds instances where a method does not contain
statements, but there is no comment. By explicitly commenting empty methods
it is easier to distinguish between intentional (commented) and unintentional
empty methods.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//MethodDeclaration/Block[count(BlockStatement) = 0 and @containsComment = 'false']
 ]]>
             </value>
          </property>
      </properties>
      <priority>3</priority>
      <example>
  <![CDATA[
public void doSomething() {
}
 ]]>
      </example>
    </rule>
    
    <rule name="UncommentedEmptyConstructor"
   		language="java"
          since="3.4"
          message="Document empty constructor"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/design.html#UncommentedEmptyConstructor">
      <description>
Uncommented Empty Constructor finds instances where a constructor does not
contain statements, but there is no comment. By explicitly commenting empty
constructors it is easier to distinguish between intentional (commented)
and unintentional empty constructors.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and ($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false']
 ]]>
             </value>
          </property>
          <property name="ignoreExplicitConstructorInvocation" type="Boolean" description="Ignore explicit constructor invocation when deciding whether constructor is empty or not" value="false"/>
      </properties>
      <example>
  <![CDATA[
public Foo() {
  super();
}
 ]]>
      </example>
    </rule>
    
    <rule name="UseCollectionIsEmpty"
         since="3.9"
         message="Substitute calls to size() == 0 (or size() != 0) with calls to isEmpty()"
         class="net.sourceforge.pmd.lang.java.rule.design.UseCollectionIsEmptyRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/design.html#UseCollectionIsEmpty">
         <description>
The isEmpty() method on java.util.Collection is provided to determine if a collection has any elements.
Comparing the value of size() to 0 does not convey intent as well as the isEmpty() method.
      </description>
      <priority>3</priority>
      <example>
    <![CDATA[
public class Foo {
	void good() {
       	List foo = getList();
		if (foo.isEmpty()) {
			// blah
		}
   	}

    void bad() {
   	    List foo = getList();
			if (foo.size() == 0) {
				// blah
			}
    	}
}
    ]]>
      </example>
    </rule>
    
    <rule name="AvoidCatchingThrowable"
   		since="1.2"
         message="A catch statement should never catch throwable since it includes errors."
          class="net.sourceforge.pmd.lang.java.rule.strictexception.AvoidCatchingThrowableRule"
          externalInfoUrl="http://pmd.sourceforge.net/pmd-5.0.5/rules/java/strictexception.html#AvoidCatchingThrowable">
      <description>
Catching Throwable errors is not recommended since its scope is very broad. It includes runtime issues such as 
OutOfMemoryError that should be exposed and managed separately.
      </description>
      <priority>3</priority>
      <example>
	<![CDATA[
public void bar() {
	try {
     // do something
    } catch (Throwable th) {  // should not catch Throwable
		th.printStackTrace();
    }
  }
	]]>
      </example>
    </rule>
    
    <rule name="AvoidCatchingNPE"
    message="Avoid catching NullPointerException; consider removing the cause of the NPE."
    class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#AvoidCatchingNPE">
    <description>
      Code should never throw NPE under normal circumstances.  A catch block may hide the original error, causing other more subtle errors in its wake.
    </description>
    <example>  <![CDATA[
public class Foo {
 void bar() {
  try {
   // do something
   }  catch (NullPointerException npe) {
  }
 }
}
]]>
         </example>
    <priority> 3 </priority>
    <properties>
      <property name="xpath">
        <value>
            <![CDATA[
//CatchStatement/FormalParameter/Type
 /ReferenceType/ClassOrInterfaceType[@Image='NullPointerException']
 ]]>
        </value>
      </property>
    </properties>
  </rule>
  
  <rule name="AvoidThrowingRawExceptionTypes"
      message="Avoid throwing raw exception types."
      class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#AvoidThrowingRawExceptionTypes">
    <description>
Avoid throwing certain exception types.  Rather than throw a raw RuntimeException, Throwable,
 Exception, or Error, use a subclassed exception or error instead.
    </description>
 <example>
      <![CDATA[
public class Foo {
public void bar() throws Exception {
  throw new Exception();
 }
}
]]>
    </example>
    <priority> 1 </priority>
    <properties>
      <property name="xpath">
        <value>
            <![CDATA[
//AllocationExpression
 /ClassOrInterfaceType[
 @Image='Throwable' or
 @Image='Exception' or
 @Image='Error' or
 @Image='RuntimeException']
 ]]>
        </value>
      </property>
    </properties>
  </rule>
  
  <rule name="AvoidRethrowingException" 
    message="A catch statement that catches an exception only to rethrow it should be avoided."
    class="net.sourceforge.pmd.lang.rule.XPathRule" language="java">
    <description>
     Catch blocks that merely rethrow a caught exception only add to code size and runtime complexity.
    </description>
    <example>  <![CDATA[
  public class Foo {
   void bar() {
    try {
    // do something
    }  catch (SomeException se) {
       throw se;
    }
   }
  }
  ]]>
    </example>
    <priority> 3 </priority>
    <properties>
    <property name="xpath">
      <value>
        <![CDATA[
//CatchStatement[FormalParameter
 /VariableDeclaratorId/@Image = Block/BlockStatement/Statement
 /ThrowStatement/Expression/PrimaryExpression[count(PrimarySuffix)=0]/PrimaryPrefix/Name/@Image
 and count(Block/BlockStatement/Statement) =1]
 ]]>
      </value>
    </property>
    </properties>
  </rule>
  
  <rule name="SystemPrintln"
         message="System.out.print is used"
         class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
          externalInfoUrl="http://pmd.sourceforge.net/rules/logging-java.html#SystemPrintln">
     <description>
System.(out|err).print is used, consider using a logger.
     </description>
     <properties>
         <property name="xpath">
             <value>
                 <![CDATA[
//Name[
    starts-with(@Image, 'System.out.print')
    or
    starts-with(@Image, 'System.err.print')
    ]
                ]]>
             </value>
         </property>
     </properties>
        <priority>2</priority>
     <example>
 <![CDATA[
class Foo{
    Logger log = Logger.getLogger(Foo.class.getName());
    public void testA () {
        System.out.println("Entering test");
        // Better use this
        log.fine("Entering test");
    }
}
]]>
     </example>
     </rule>
     
     <rule  name="AvoidPrintStackTrace"
           message="Avoid printStackTrace(); use a logger call instead."
           class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
		   externalInfoUrl="http://pmd.sourceforge.net/rules/logging-java.html#AvoidPrintStackTrace">
           <description>
Avoid printStackTrace(); use a logger call instead.
           </description>
           <properties>
             <property name="xpath">
             <value>
<![CDATA[
//PrimaryExpression
 [PrimaryPrefix/Name[contains(@Image,'printStackTrace')]]
 [PrimarySuffix[not(boolean(Arguments/ArgumentList/Expression))]]
]]>
             </value>
             </property>
           </properties>
           <priority>3</priority>
           <example>
<![CDATA[
class Foo {
 void bar() {
  try {
   // do something
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
}
]]>
           </example>
    </rule>
    
    <rule name="IntegerInstantiation"
          message="Avoid instantiating Integer objects. Call Integer.valueOf() instead."
	  class="net.sourceforge.pmd.lang.rule.XPathRule" language="java">
      <description>In JDK 1.5, calling new Integer() causes memory allocation.  Integer.valueOf() is more memory friendly.</description>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//PrimaryPrefix
 /AllocationExpression
  [not (ArrayDimsAndInits)
   and (ClassOrInterfaceType/@Image='Integer'
    or ClassOrInterfaceType/@Image='java.lang.Integer')]
                  ]]>
              </value>
          </property>
      </properties>
        <priority>2</priority>
      <example>
  <![CDATA[
public class Foo {
 private Integer i = new Integer(0); // change to Integer i = Integer.valueOf(0);
}
   ]]>
      </example>
    </rule>
    
    <rule
        name="MDBAndSessionBeanNamingConvention"
        since="4.0"
        class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
        message="SessionBean or MessageBean should be suffixed by Bean"
        externalInfoUrl="http://pmd.sourceforge.net/rules/j2ee.html#MDBAndSessionBeanNamingConvention">
        <description>
        The EJB Specification state that any MessageDrivenBean or SessionBean should be suffixed by Bean.
        </description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration
[
    (
        (./ImplementsList/ClassOrInterfaceType[ends-with(@Image,'SessionBean')])
        or
        (./ImplementsList/ClassOrInterfaceType[ends-with(@Image,'MessageDrivenBean')])
    )
    and
    not
    (
        ends-with(@Image,'Bean')
    )
]
             ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
            /* Proper name */
            public class SomeBean implements SessionBean{}
            ]]>
        </example>
        <example>
            <![CDATA[
            /* Bad name */
            public class MissingTheProperSuffix implements SessionBean {}
            ]]>
        </example>
    </rule>

    <rule
        name="RemoteSessionInterfaceNamingConvention"
        since="4.0"
        class="net.sourceforge.pmd.lang.rule.XPathRule" language="java"
        message="Remote Home interface of a Session EJB should be suffixed by 'Home'"
        externalInfoUrl="http://pmd.sourceforge.net/rules/j2ee.html#RemoteSessionInterfaceNamingConvention">
        <description>
        Remote Home interface of a Session EJB should be suffixed by 'Home'.
        </description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassOrInterfaceDeclaration
[
    (
        (./ExtendsList/ClassOrInterfaceType[ends-with(@Image,'EJBHome')])
    )
    and
    not
    (
        ends-with(@Image,'Home')
    )
]
                    ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
            /* Proper name */
            public interface MyBeautifulHome extends javax.ejb.EJBHome {}
            ]]>
        </example>
        <example>
            <![CDATA[
            /* Bad name */
            public interface MissingProperSuffix extends javax.ejb.EJBHome {}
            ]]>
        </example>
    </rule>
    
      
	</ruleset>
